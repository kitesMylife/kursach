// библиотека для работы с потоками ввода вывода
#include <iostream>
// библиотека для работы со строками
#include <string>
// библиотека для работы с файловыми потоками
#include <fstream>

// класс для представления байтов в виде битовой последовательности
class bitBuffer
{

public:
	// конструктор, принимающий указатели на символьный буфер, его размер и флаг, если необходима очистка буфера
	bitBuffer(char * inputData, int inputDataSize, bool needClearing = false)
	{
		// текущий байт
		currentByte = 0;
		// текущий бит
		currentBit = 0;
		// присваиваем указатель на символьный буфер
		buffer = inputData;
		// размер буфера в байтах
		sizeByte = inputDataSize;
		// размер буфера в битах
		sizeBits = sizeByte * 8;
		// если необходима очистка
		if (needClearing)
		{
			// проходим в цикле по символьному буферу
			for (int i = 0; i < inputDataSize; i++)
			{
				// обнуляем элементы
				buffer[i] = 0;
			}
			// обнуляем размер в байтах
			sizeByte = 0;
			// обнуляем размер в битах
			sizeBits = 0;
		}
		
	}
	// метод добавления бита в последовательность
	void addBit(bool bit)
	{
		// увеличиваем счетчик битов
		sizeBits++;
		// если единица(true)
		if (bit)
		{
			// то производим побитовое или с текущим битом
			buffer[currentByte] |= 1 << currentBit;
		}
		else
		{
			// если 0(false)
			// то производим побитовое И с инвертированным нужным нам битом
			buffer[currentByte] &= ~(1 << currentBit);
		}
		// увеличиваем битовый индекс(счетчик текущего бита
		currentBit++;
		// если бит больше, равен 8, то переходим на следующий байт
		if (currentBit >= 8)
		{
			// текущий бит устанавливаем в 0
			currentBit = 0;
			// увеличиваем индекс текущего байта на единицу
			currentByte++;
			// размер в байтах увеличиваем на единицу
			sizeByte++;
		}
	}
	// оператор обращения по индексу бита
	bool operator[](int indexBits)
	{
		// вычисляем нужный нам байт
		int needByte = indexBits / 8;
		// вычисляем нужный нам бит в байте
		int needBit = indexBits - needByte * 8;
		// получаем состояние нужного нам бита посредством логического И и преобразования результата в Bool
		return bool(buffer[needByte] & (1 << needBit));
	}
	// метод вывода содержимого в консоль
	void toString()
	{
		// в цикле проходим по всем битам
		for (int i = 0; i < sizeBits; i++)
		{
			// если бит делится нацело на ноль, делаем пробел(разделяя байты)
			if ((i % 8) == 0)
				std::cout << " ";
			// выводим состояние текущего бита при помощи оператора индексации
			std::cout << (this->operator[](i));
		}
	}
	// переменная текущего байта
	int currentByte;
	// переменная текущего бита
	int currentBit;
	// переменная размера в байтах
	size_t sizeByte;
	// переменная размера в битах
	size_t sizeBits;
	// указатель на символьный буффер
	char *buffer;

};

// функция вычисления удаленности первого установленного в единицу бита в байте
int sizeBite(int value)
{
	// проходим в цикле побитово с конца байта до начала
	for (int j = 7; j >= 0; j--)
	{
		// если встречаем единицу, то возвращаем число пройденных нулей.
		if (bool((value & (1 << j))))
			return j+1;
	}
	// если же все биты установлены в 0, возвращаем 0
	return 0;
}

// функция декодирования, принимает указатель на входной символный массив с размеров и выходной символьный массив с размеромс
int eliasGammaDecode(char* source, int inputSize, char* dest, int bufferSize)
{
	// создаем класс битовой последовательности, инициализируя его выходным массивом и очищаем
	bitBuffer out(dest, bufferSize,true);
	// создаем класс битовой последовательности, инициализируя его входным массивом без очистки 
	bitBuffer buf(source, inputSize);
	// индекс ткущего байта
	int index = 0;
	// количество посчитанных нулей
	int countBit = 0;
	// тестовый вывод в консоль входного массива
	// buf.toString();
	// проходим в цикле по всем битам входного массива
	for (int i = 0; i < buf.sizeBits; i++)
	{
		// если бит установлен в 0
		if (buf[i] == false)
		{
			// прибавляем счетчик 0
			countBit++;
		}
		// как только встречаем бит установленный в 1
		if (buf[i] == true)
		{
			
			// проверяем, есть ли в буфере необходимое количество бит
			if (buf.sizeBits < i + countBit)
			{
				// если нет, возвращаем -1 - ошибку
				return -1;
			}
			// переменная для декодированного значения
			int decode = 0;
			// проходим от нулевого до последнего значимого декодируемого бита 
			for (int j = 0; j <= countBit; j++)
			{
				// если бит установлен в 1, то устанавливаем его в переменную. Если 0, то ничего не делаем, т.к. переменная у нас обнулена
				if (buf[i + j] == true)
				{
					// если бит установлен в 1, то производим побитовое или с текущим битом
					decode |= 1 << (countBit - j);
				}
			}
			// сдвигаем счетчик цикла на обработанные нами биты
			i += countBit;
			// счетчик нулей сбрасываем
			countBit = 0;
			// заносим декодированный байт в выходной массив
			dest[index] = decode;
			// уведтчтваем индекс выходного массива
			index++;
		}
	}
	dest[index] = '\0';
	// возвращаем количество декодированных байтов
	return index;
}

// функция шифрования, принимает указатель на входной символный массив с размеров и выходной символьный массив с размером
int eliasGammaEncode(char* source, int inputSize,char* dest, int bufferSize)
{
	// создаем класс битовой последовательности, инициализируя его выходным массивом и очищаем
	bitBuffer out(dest, bufferSize,true);

	// индекс выходного массива
	int index = 0;
	// количество нулей
	int countBit = 0;
	
	// проходим в цикле по всему входному массиву
	for (int i = 0; i < inputSize; i++)
	{
		// получаем количество нулей, которые нужно добавить перед значимыми битами
		int y = sizeBite(source[i]);
		
		// добавляем нужное количество нулей
		for (int j = 0; j < y-1; j++)
		{
			out.addBit(false);
		}
		// добавляем значимые биты байта
		for (int j = y - 1; j >= 0; j--)
		{
			out.addBit((bool(source[i] & (1 << j))));
		}
	}
	// возвращаем размер в байтах зашифрованного массива
	return out.sizeByte+1;
}

// функция получения размера в байтах
size_t sizeFile(std::string inFile) 
{
	// открываем файловый поток чтения 
	std::ifstream file(inFile.c_str());
	// счетчик байтов
	size_t sizeBytes = 0; 

	// читаем побайтово файл, пока не будет обнаружен конец файла
	while (!file.eof()) 
	{ 
		// читаем по одному символу
		file.get();
		// увеличиваем счетчик байтов на единицу
		sizeBytes++;              
	}

	// закрываем файловый поток
	file.close(); 

	// последняя итерация цикла лишняя, поэтому отнимаем единицу
	sizeBytes--; 
	// возвращаем количество байтов в файле
	return sizeBytes;
}


// основная функция программы
int main(int argc, char *argv[])
{
	// если аргументов нет или аргумент равняется -h, выводим описание
	if (argc == 1 || (argc == 2 && strcmp(argv[1],"-h")==0))
	{
		std::cout << "This is Elias gamma coding compressor for ASCII text files.\n"
			<< "General options :\n"
			<< "\t-c[--compress] Compress file(-c init.txt output.compressed)\n"
			<< "\t-d[--decompress] Decompress file(-d output.compressed check.txt)\n"
			<< "\t-h[--help] Show help$\n";
		// выходим из программы
		return 0;
	}

	// если количество аргументов меньше 4, то выдаем предупреждение и выходим из программы
	if (argc < 4)
	{
		std::cout << "Need more arguments, use -h show help\n";
		// выходим из программы
		return 0;
	}

	// если аргументы являются командами -c или -d, начинаем обработку 
	if (strcmp(argv[1],"-c") == 0 || strcmp(argv[1],"-d") == 0)
	{
		// буфер для хранения данных из файла
		char buffer[65535];
		// путь к исходному файлу
		std::string filenameIn(argv[2]);
		// путь к файлу с результатами
		std::string filenameOut(argv[3]);
		// создаем объект файлового потока к исходному файлу
		std::ifstream stream(filenameIn);
		// если не удается открыть исходный файл, выдаем предупреждение и выходим из программы
		if (!stream.is_open())
		{
			std::cout << "Not find input file: " << filenameIn <<std::endl;
			// выходим из программы
			return 0;
		}
		// получаем размер файла в байтах
		int len = sizeFile(filenameIn);
		// переходим в начало файла
		stream.seekg(0, std::ios::beg);
		// проверяем поместится ли файл в наш буфер, если нет выдаем предупреждение и выходим из программы
		if (len > 65535)
		{
			std::cout << "File size is very big.\n";
			// выходим из программы
			return 0;
		}
		// читаем файл в буфер
		stream.read(buffer, len);
		// создаем выходной буфер
		char bufferOut[65535];
		// количество обработанных байтов
		int size = 0;
		// если компрессия
		if (strcmp(argv[1], "-c") == 0)
		{
			// шифруем буфер
			size = eliasGammaEncode(buffer, len, bufferOut, 65535);
			// если шифрование успешно, выводим сообщение 
			if (size != -1)
			{
				std::cout << "Done! Compression ratio - bytes "<< len << " / " << size <<" bytes = " << double(len) / double(size) << "$\n";
			}
			else
			{
				// иначе выдаем ошибку и выходим из программы
				std::cout << "Fail! Unknown error\n";
				// выходим из программы
				return 0;
			}
		}
		else
		{
			// если выбрана дешифровка
			// дешифруем буфер
			size = eliasGammaDecode(buffer, len, bufferOut, 65535);
			// если дешифрование успешно, выводим сообщение 
			if (size != -1)
			{
				std::cout << "Done!\n";
			}
			else
			{
				// иначе выдаем ошибку и выходим из программы
				std::cout << "Fail! Unknown error\n";
				// выходим из программы
				return 0;
			}
		}
		
		// создаем файловый поток для выходного файла
		std::ofstream ofstream(filenameOut);
		// если не удается открыть файл на запись, выводим сообщение и выходим из программы
		if (!stream.is_open())
		{
			std::cout << "Error create output file: " << filenameOut << std::endl;
			// выходим из программы
			return 0;
		}
		// записываем данные в выходной файл
		ofstream.write(bufferOut, size);
		// выходим из программы
		return 0;
	}
	else
	{
		// если введена неизвестная команда, выводим сообщение
		std::cout << "Unknown command, use -h for help\n";
	}
	// выходим из программы
	return 0;
}
